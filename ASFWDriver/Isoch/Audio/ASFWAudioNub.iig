//
// ASFWAudioNub.iig
// ASFWDriver
//
// Audio nub published by ASFWDriver when music subunit is discovered.
// ASFWAudioDriver (IOUserAudioDriver) matches on this nub.
//
// Cross-process communication:
//   ASFWAudioNub allocates shared memory (IOBufferMemoryDescriptor) for both
//   TX and RX audio queues. Both ASFWAudioDriver and Isoch contexts map this
//   memory and communicate via lock-free SPSC queues.
//

#ifndef ASFWAudioNub_h
#define ASFWAudioNub_h

#include <DriverKit/IOService.iig>
#include <DriverKit/IOBufferMemoryDescriptor.iig>
#include <DriverKit/OSString.iig>
#include <DriverKit/OSArray.iig>
#include <atomic>
#include <cstdint>

class ASFWDriver;

// Audio nub that bridges ASFWDriver (hardware) to ASFWAudioDriver (CoreAudio)
// Properties set by ASFWDriver:
//   - ASFWDeviceName (OSString): Device name from config ROM
//   - ASFWChannelCount (OSNumber): Number of audio channels
//   - ASFWSampleRates (OSArray of OSNumber): Supported sample rates
//   - ASFWGUID (OSNumber): Device GUID for identification

class ASFWAudioNub: public IOService
{
public:
    virtual bool init() override;
    virtual void free() override;
    virtual kern_return_t Start(IOService* provider) override;
    virtual kern_return_t Stop(IOService* provider) override;

    // RPC method: AudioDriver calls this to get shared TX queue memory
    // Returns a retained IOBufferMemoryDescriptor that the caller must release
    // This is NOT LOCALONLY - it's callable across process boundaries
    virtual kern_return_t CopyTransmitQueueMemory(
        IOBufferMemoryDescriptor** outMemory,
        uint64_t* outBytes);

    // RPC method: AudioDriver calls this to get shared output audio buffer
    // This buffer is used by IOUserAudioStream AND IT DMA for ZERO-COPY
    // CoreAudio writes here, IT DMA reads directly - no intermediate copy!
    virtual kern_return_t CopyOutputAudioMemory(
        IOBufferMemoryDescriptor** outMemory,
        uint64_t* outBytes);

    // LOCALONLY methods for ASFWDriver-side access (same process)
    ASFWDriver* GetParentDriver() const LOCALONLY;

    // Get the local mapping of the TX queue for IT context to consume
    uint8_t* GetTxQueueLocalMapping() const LOCALONLY;
    uint64_t GetTxQueueBytes() const LOCALONLY;

    // ZERO-COPY: Get the local mapping of output audio buffer for IT DMA
    // This is the same memory that IOUserAudioStream writes to
    uint8_t* GetOutputAudioLocalMapping() const LOCALONLY;
    uint64_t GetOutputAudioBytes() const LOCALONLY;
    uint32_t GetOutputAudioFrameCapacity() const LOCALONLY;
    
    // Set channel count directly (called by AVCDiscovery after Create())
    // Must be called before CopyTransmitQueueMemory / CopyOutputAudioMemory
    void SetChannelCount(uint32_t channels) LOCALONLY;
    uint32_t GetChannelCount() const LOCALONLY;

    // Stream mode selected during discovery:
    //   0 = non-blocking, 1 = blocking
    void SetStreamMode(uint32_t modeRaw) LOCALONLY;
    uint32_t GetStreamMode() const LOCALONLY;

    // ZERO-COPY SYNC: Write position tracking
    // Called by ASFWAudioDriver after each CoreAudio write completes
    void UpdateOutputWritePosition(uint32_t newWriteFrame) LOCALONLY;
    uint32_t GetOutputWritePosition() const LOCALONLY;

    // RPC method: AudioDriver calls this to get shared RX queue memory
    // Returns a retained IOBufferMemoryDescriptor that the caller must release
    virtual kern_return_t CopyRxQueueMemory(
        IOBufferMemoryDescriptor** outMemory,
        uint64_t* outBytes);

    // LOCALONLY methods for controller-side RX queue access (same process)
    uint8_t* GetRxQueueLocalMapping() const LOCALONLY;
    uint64_t GetRxQueueBytes() const LOCALONLY;
    void EnsureRxQueueCreated() LOCALONLY;

    // Device identity for protocol bridge routing
    void SetGuid(uint64_t guid) LOCALONLY;
    uint64_t GetGuid() const LOCALONLY;

    // RPC protocol-backed boolean control bridge (AudioDriver -> ASFWDriver process)
    virtual kern_return_t GetProtocolBooleanControl(
        uint32_t classIdFourCC,
        uint32_t element,
        bool* outValue);

    virtual kern_return_t SetProtocolBooleanControl(
        uint32_t classIdFourCC,
        uint32_t element,
        bool value);
};

struct ASFWAudioNub_IVars {
    IOService* parentDriver;              // ASFWDriver instance (not retained, provider lifetime)
    IOBufferMemoryDescriptor* txQueueMem; // Shared memory for TX audio queue
    IOMemoryMap* txQueueMap;              // Local mapping of txQueueMem
    uint64_t txQueueBytes;                // Size of shared memory

    // Audio channel count (read from ASFWDriver properties)
    uint64_t guid{0};
    uint32_t channelCount{2};
    uint32_t streamModeRaw{0};             // 0=non-blocking, 1=blocking

    // ZERO-COPY: Shared output audio buffer for IOUserAudioStream AND IT DMA
    IOBufferMemoryDescriptor* outputAudioMem; // Shared output audio buffer
    IOMemoryMap* outputAudioMap;              // Local mapping for IT DMA
    uint64_t outputAudioBytes;                // Size of buffer
    uint32_t outputAudioFrameCapacity;        // Frame capacity (bytes / bytesPerFrame)

    // ZERO-COPY SYNC: Atomic write position updated by ASFWAudioDriver
    // IT Context reads this to know safe read zone
    std::atomic<uint32_t> outputAudioWriteFrame{0};

    // RX shared memory queue (mirrors TX queue pattern)
    IOBufferMemoryDescriptor* rxQueueMem{nullptr};
    IOMemoryMap* rxQueueMap{nullptr};
    uint64_t rxQueueBytes{0};
};

#endif /* ASFWAudioNub_h */
